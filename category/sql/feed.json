{
    "version": "https://jsonfeed.org/version/1",
    "title": "Youyi's Blog • All posts by \"sql\" category",
    "description": "尤一的计算机学习之路",
    "home_page_url": "https://stayone1.github.io",
    "items": [
        {
            "id": "https://stayone1.github.io/2022/09/01/sql/",
            "url": "https://stayone1.github.io/2022/09/01/sql/",
            "title": "SQL",
            "date_published": "2022-09-01T11:07:00.000Z",
            "content_html": "<p><em>这个主要是整理之前学习时的笔记 持续更新 欢迎大家留言 批评指正</em></p>\n<h1 id=\"SQL\"><a href=\"#SQL\" class=\"headerlink\" title=\"SQL\"></a>SQL</h1><h2 id=\"SQL通用语法\"><a href=\"#SQL通用语法\" class=\"headerlink\" title=\"SQL通用语法\"></a>SQL通用语法</h2><ol>\n<li><p>SQL语句可以单行或多行书写，以分号结尾。</p>\n</li>\n<li><p>可以使用空格和缩进提高可读性。</p>\n</li>\n<li><p>MySQL中SQL语句不区分大小写，关键字建议大写。</p>\n</li>\n<li><p>3种注释</p>\n<ul>\n<li><p>单行注释</p>\n<pre><code class=\"sql\">-- 注释内容\n# 注释内容\n</code></pre>\n</li>\n<li><p>多行注释</p>\n<pre><code class=\"sql\">/*\n注释\n*/\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"DDL语句\"><a href=\"#DDL语句\" class=\"headerlink\" title=\"DDL语句\"></a>DDL语句</h2><p>DDL（Data Definition Language）数据定义语言，用来定义数据库对象“数据库，表，列等。关键字：create,drop,alter等</p>\n<ol>\n<li><p>操作数据库：CRUD</p>\n<ol>\n<li><p>C(Create):创建</p>\n</li>\n<li><p>R(Retrieve):查询</p>\n</li>\n<li><p>U(Update):修改</p>\n</li>\n<li><p>D(Delete):删除</p>\n</li>\n<li><p>使用数据库</p>\n<pre><code class=\"sql\">#创建\n基本创建\ncreate database 数据库名;\n如果不存在，再进行创建\ncreate database if not exists 数据库名;\n指定字符集\ncreate database 数据库名 character set 字符集;\n\n#查询\n查询所有数据库的名称\nshow databases;\n查看某数据库创建语句\nshow create database 数据库名称;\n\n#修改\n修改数据库的字符集\nalter database 数据库名 character set 字符集名;\n\n#删除\n删除数据库\ndrop database 数据库名称;\n判断是否存在\ndrop database if exists 数据库名字;\n\n#使用\n查询当前正在使用的数据库\nselect database();\n切换到对应数据库\nuse 数据库名;\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>操作表：CRUD</p>\n<pre><code class=\"SQL\">#创建\n创建表\ncreate table 表名(\n    列名1 数据类型1,\n    列名2 数据类型2,\n    ...\n    列名n 数据类型n\n);\n复制表\ncreate table 表名 like 表名;\n#查询\n查询某个数据库中所有的表名称\nshow tables;\n查询表结构\ndesc 表名;\n#修改\n修改表名\nalter table 表名 rename to 新表名;\n修改表的字符集\nalter table 表名 character set 字符集;\n添加列\nalter table 表名 add 列名 数据类型;\n修改列名、类型\nalter table 表名 change 列名 新列名 类型;\n只修改列类型\nalter table 表名 modify 列名 列类型;\n删除列\nalter table 表名 drop 列名;\n#删除\ndrop table 表名;\ndrop table if exists 表名;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"DQL语句\"><a href=\"#DQL语句\" class=\"headerlink\" title=\"DQL语句\"></a>DQL语句</h2><p>DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录。关键字：select,where等</p>\n<ul>\n<li>基础查询  字段名后可以加 [AS] 别名</li>\n<li>条件查询  条件运算符 between … and …    and   or</li>\n<li>分组查询  </li>\n<li>排序查询  升序ASC 降序DESC</li>\n<li>分页查询 起始索引（从0开始），每页展示记录数</li>\n</ul>\n<ol>\n<li><p>基础查询</p>\n<ol>\n<li><p>多个字段的查询</p>\n</li>\n<li><p>去除重复</p>\n</li>\n<li><p>计算列</p>\n</li>\n<li><p>起别名</p>\n<pre><code class=\"sql\">#多个字段的查询\nselect 字段1,字段2,...,字段n from 表名;\nselect * from 表名;\n#去除重复\nselect distinct 字段名 from 表名;\n#计算列，数值型\nselect 字段1,字段2,字段1+字段2 from 表名;\nselect 字段1,字段2,字段1+IFNULL(字段2,0) from 表名; //当某字段值为null时\n#起别名\nselect 字段1,字段2,字段1+IFNULL(字段2,0) AS(可以省略) 总分 from 表名; \n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>条件查询</p>\n<ol>\n<li><p>where 子句后跟条件</p>\n</li>\n<li><p>运算符</p>\n<pre><code class=\"sql\">#where\nselect 字段名 from 表名 where 条件;\n#运算符\n&lt; &gt; &lt;= &gt;= == &lt;&gt;(!=)\nbetween and \nlike\nis null\nand 或 &amp;&amp;\nor 或 ||\nnot 或 !\nin\n#注意\nNULL值不能使用运算符判断  要用is\nwhere 字段名 is null\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>模糊查询</p>\n<pre><code class=\"sql\">#占位符\n_:单个任意字符\n%:多个任意字符\n#语法\nselect 字段 from 表名 where 字段名 like ;\n</code></pre>\n</li>\n<li><p>排序查询</p>\n<pre><code class=\"sql\">#语法\norder by 排序字段1 排序方式1,...,排序字段n 排序方式n;\n排序方式省略时默认按照升序排序\n#排序方式\nASC：升序，默认\nDESC：降序\n#多字段优先级\n语句前面的字段更优先\n</code></pre>\n</li>\n<li><p>聚合函数(将一列数据纵向计算)</p>\n<ol>\n<li><p>count:计算个数</p>\n</li>\n<li><p>max:计算最大值</p>\n</li>\n<li><p>min:计算最小值</p>\n</li>\n<li><p>sum:求和</p>\n</li>\n<li><p>avg:平均值</p>\n<pre><code class=\"sql\">#count\nselect count(*) from 表名;\nselect count(字段名) from 表名;\n字段可以使用IFNULL转换\n#max\nselect max(字段名) from 表名;\n#min\nselect min(字段名) from 表名;\n#sum\nselect sum(字段名) from 表名;\n#avg\n#注意\n聚合函数的计算，排除NULL值\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>分组查询</p>\n<pre><code class=\"sql\">#语法\ngroup by 分组字段;\n#注意\n分组之后查询的字段：分组字段、聚合函数\n#分组前过滤，即不参与分组\nselect 字段 from 表名 where 条件 group by 字段;\n#分组后过滤\nselect 字段 from 表名 group by 字段 having 条件;\n\n#where 和 having 的区别\nwhere 在分组之前进行限定，如果不满足条件，则不参与分组。 having 在分组之后进行限定，如果不满足结果，则不会被查询出来。\nwhere 后不可以跟聚合函数，having可以进行聚合函数的判断\n</code></pre>\n</li>\n<li><p>分页查询</p>\n<pre><code class=\"sql\">#语法\nlimit 开始的索引,每页查询的条数;\n#公式\n开始的索引 = (当前页码-1)*每页显示的条数\n#分页操作是一个方言，不同数据库存在区别\nlimit是mysql的\n</code></pre>\n</li>\n</ol>\n<h3 id=\"DQL-编写顺序\"><a href=\"#DQL-编写顺序\" class=\"headerlink\" title=\"DQL-编写顺序\"></a>DQL-编写顺序</h3><pre><code class=\"sql\">SELECT\n      字段列表\nFROM\n      表名列表\nWHERE\n      条件列表 #分组之前过滤\nGROUP BY\n      分组字段列表\nHAVING\n      分组后条件列表 #分组之后过滤\nORDER BY \n      排序字段列表\nLIMIT\n      分页参数\n</code></pre>\n<hr>\n<h3 id=\"DQL-执行顺序\"><a href=\"#DQL-执行顺序\" class=\"headerlink\" title=\"DQL-执行顺序\"></a>DQL-执行顺序</h3><pre><code class=\"sql\">FROM\n      表名列表\nWHERE\n      条件列表\nGROUP BY\n      分组字段列表\nHAVING\n      分组后条件列表\nSELECT\n      字段列表\nORDER BY\n      排序字段列表\nLIMIT\n      分页参数\n</code></pre>\n<h2 id=\"DCL语句\"><a href=\"#DCL语句\" class=\"headerlink\" title=\"DCL语句\"></a>DCL语句</h2><ul>\n<li><p>DCL-介绍</p>\n<p>DCL-数据控制语言，用来管理数据库用户以及用户对数据库的访问权限,关键字：GRANT,REVOKE等</p>\n</li>\n<li><p>DCL-管理用户</p>\n<ul>\n<li><p>查询用户</p>\n<pre><code class=\"sql\">USE mysql; \nSELLECT * FROM user;\n#注意\n%指可以在任意主机登录\n</code></pre>\n</li>\n<li><p>创建用户</p>\n<pre><code class=\"sql\">CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;\n</code></pre>\n</li>\n<li><p>修改用户密码</p>\n<pre><code class=\"sql\">ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password by &#39;新密码&#39;;\n#root改其它\nupdate user set password = password(&#39;新密码&#39;) where user = &#39;用户名&#39;;\nset password for &#39;用户名&#39;@&#39;主机名&#39; = password(&#39;新密码&#39;);\n#mysql 忘记root密码\n1. cmd -- &gt; net stop mysql  //管理员\n2. 使用无验证方式启动Mysql服务  mysqld --skip-grant-tables\n3. 新开cmd然后直接输入mysql 回车 无验证登录后修改密码\n4. 任务管理器结束mysqld进程\n5. 打开mysql服务 net start mysql\n6. 正常登录\n</code></pre>\n</li>\n<li><p>删除用户</p>\n<pre><code class=\"sql\">DROP USER &#39;用户名&#39;@&#39;主机名&#39;;\n#权限说明\nusage ： 可以登录\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>DCL-授权</p>\n<ul>\n<li><p>查询权限</p>\n<pre><code class=\"sql\">show grants for &#39;用户名&#39;@&#39;主机名&#39;;\n</code></pre>\n</li>\n<li><p>授予权限</p>\n<pre><code class=\"sql\">grant 权限列表 on 数据库.表名 to &#39;用户名&#39;@&#39;主机名&#39;;\n#授予所有权限\ngrant all on *.* to &#39;用户名&#39;@&#39;主机名&#39;;\n</code></pre>\n</li>\n<li><p>撤销权限</p>\n<pre><code class=\"sql\">revoke 权限列表 on 数据库.表名 from &#39;用户名&#39;@&#39;主机名&#39;;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>DBA：数据库管理员</p>\n</li>\n</ul>\n<h2 id=\"DML语句\"><a href=\"#DML语句\" class=\"headerlink\" title=\"DML语句\"></a>DML语句</h2><p>DML(Data Manipulation Language)数据操作语言 用来对表中的数据进行增删查改。关键字：insert,delete,update等</p>\n<ol>\n<li><p>添加数据</p>\n</li>\n<li><p>删除数据</p>\n</li>\n<li><p>修改数据</p>\n<pre><code class=\"sql\">#添加数据\ninsert into 表名(列名1,列名2,...,列名n) values(值1,值2,...,值n);\n列名要和值一一对应\n如果不指定列名，则默认给所有列添加值\n除了数字，其他都要用引号引起来，单双引号都可以\n\n#删除数据\ndelete from 表名 [where 条件];\n如果不加条件，则删除表中所有的记录\n如果要删除表中所有记录，有两种方式。不推荐使用delete，效率低。建议使用后者。\n\n删除表，然后再创建一个一模一样的空表\nTRUNCATE TABLE 表名;\n\n#修改数据\nupdate 表名 set 列名1 = 值1,... [where 条件];\n如果不加任何条件，则会修改所有记录\n</code></pre>\n</li>\n</ol>\n<h2 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h2><p>概念 ： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。</p>\n<p>分类 ： </p>\n<ol>\n<li><p>主键约束：primary key</p>\n</li>\n<li><p>非空约束：not null</p>\n</li>\n<li><p>唯一约束：unique</p>\n</li>\n<li><p>外键约束：foreign key</p>\n<pre><code class=\"sql\">#主键约束,非空且唯一，一张表只能有一个主键\n主键即表中记录的唯一标识\n\n创建表时添加约束\nCreate table stu&#123;\n    id int primary key,\n    name varchar(10) \n&#125;;\n创建表后添加约束\nalter table 表名 modify 字段名 字段类型 primary key;\n删除约束\nalter table 表名 drop primary key;\n自动增长，如果某一列是数值类型，可以使用auto_increment 可以自动增长\n创建表时添加约束，并使其自动增长\nCreate table stu&#123;\n    id int primary key auto_increment,\n    name varchar(10) \n&#125;;\n删除自动增长，并不会删除主键\nalter table 表名 modify 字段名 字段类型;\n添加自动增长\nalter table 表名 modify 字段名 字段类型 auto_increment;\n\n#非空约束\n创建表时添加约束\nCreate table stu&#123;\n    id int,\n    name varchar(10) not null\n&#125;;\n创建表后添加非空约束\nalter table 表名 modify 字段名 字段类型 not null;\n删除非空约束\nalter table 表名 modify 字段名 字段类型;\n\n#唯一约束,值不能重复\n创建表时添加约束\nCreate table stu&#123;\n    id int,\n    name varchar(10) unique\n&#125;;\n创建表后添加约束\nalter table 表名 modify 字段名 字段类型 unique;\n删除约束\nalter table 表名 drop index 字段名;\n注意\n唯一约束可以有null，但只能有一个为null\n\n#外键约束,让表与表产生关系\n创建表时，可以添加外键\ncreate table 表名&#123;\n    ...\n    外键列,\n    constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)\n&#125;;\n删除外键\nalter table 表名 drop foreign key 外键名称;\n创建表后，添加外键\nalter table 表名 add constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称);\n\n#级联\n添加外键，设置级联更新\nalter table 表名 add constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) on update cascade;\n设置级联删除\non delete cascade\n</code></pre>\n</li>\n</ol>\n<h2 id=\"数据库的设计\"><a href=\"#数据库的设计\" class=\"headerlink\" title=\"数据库的设计\"></a>数据库的设计</h2><h3 id=\"多表关系\"><a href=\"#多表关系\" class=\"headerlink\" title=\"多表关系\"></a>多表关系</h3><ol>\n<li><p>一对一(了解)</p>\n<p>如：人和身份证</p>\n<p>分析：一个人只有一个身份证，一个身份证只能对应一个人</p>\n</li>\n<li><p>一对多(多对一)</p>\n<p>如：部门和员工</p>\n<p>分析：一个部门有多个员工，一个员工只能对应一个部门</p>\n</li>\n<li><p>多对多</p>\n<p>如：学生和课程</p>\n<p>分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择</p>\n</li>\n</ol>\n<pre><code class=\"sql\">#实现\n\n#一对多关系实现\n设计两个表，使用外键实现。在多的一方建立外键，指向一的一方的主键。\n#实现多对多关系\n借助第三张表，中间表(t_xx_xx)。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。\n#一对一关系\n任意一方建立外键，指向另一方的主键。外键添加唯一约束。\n</code></pre>\n<h3 id=\"数据库设计的范式\"><a href=\"#数据库设计的范式\" class=\"headerlink\" title=\"数据库设计的范式\"></a>数据库设计的范式</h3><p>概念：设计数据库时，需要遵循的一些规范。各种范式呈递次规范，越高的范式数据库冗余越小。要遵循后边的范式，必须先遵循前边的所有范式要求。</p>\n<p>目前关系数据库有六种范式：第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)、第五范式(5NF)</p>\n<p>分类：</p>\n<ol>\n<li><p>第一范式：每一列都是不可分割的原子数据项。</p>\n<p>存在的问题：</p>\n<ul>\n<li><p>存在严重的数据冗余</p>\n</li>\n<li><p>数据添加时存在问题</p>\n</li>\n<li><p>删除数据时存在问题</p>\n</li>\n</ul>\n</li>\n<li><p>第二范式：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</p>\n<p>概念：</p>\n<ul>\n<li>函数依赖：A–&gt;B，如果通过A属性(属性组)的值，可以确定唯一B属性的值，则称B依赖于A<ul>\n<li>学号 –&gt; 姓名  </li>\n<li>(学号，课程名称) –&gt; 分数</li>\n</ul>\n</li>\n<li>完全函数依赖：A –&gt; B ，如果A是一个属性组，则B属性值的确定需要依赖A属性组中所有属性的值<ul>\n<li>(学号，课程名称) –&gt; 分数</li>\n</ul>\n</li>\n<li>部分函数依赖：A–&gt;B ，如果A是一个属性组，则B属性值只需要依赖A中某一些值即可<ul>\n<li>(学号，课程名称) –&gt; 姓名</li>\n</ul>\n</li>\n<li>传递函数依赖：A–&gt;B B–&gt;C   如果通过A属性(属性组)的值，可以确定唯一B属性的值，再通过B属性(属性组)的值，可以确定唯一C属性的值，则称C传递函数依赖于A</li>\n<li>码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码。<ul>\n<li>(学号，课程名称)</li>\n</ul>\n</li>\n<li>主属性：码属性组中的所有属性</li>\n<li>非主属性：除码属性组的属性</li>\n</ul>\n</li>\n</ol>\n<p>​\t3. 第三范式：在2NF的基础上，任何非主属性不依赖于其他非主属性(在2NF基础上消除传递依赖)</p>\n<h2 id=\"数据库的备份和还原\"><a href=\"#数据库的备份和还原\" class=\"headerlink\" title=\"数据库的备份和还原\"></a>数据库的备份和还原</h2><ol>\n<li><p>命令行方式</p>\n<pre><code class=\"sql\">#备份\nmysqldump -u用户名 -p密码 数据库名 &gt; 保存的路径    //路径包含文件名后缀\n#还原\n登录\n创建数据库\n使用数据库\n执行文件 source 文件路径\n</code></pre>\n</li>\n<li><p>图形化工具</p>\n</li>\n</ol>\n<h2 id=\"多表查询\"><a href=\"#多表查询\" class=\"headerlink\" title=\"多表查询\"></a>多表查询</h2><p>笛卡尔积</p>\n<ol>\n<li><p>内连接查询</p>\n<ol>\n<li>隐式内连接：使用where条件消除无用数据</li>\n<li>显式内连接：<br>&#96;&#96;&#96; sql<br>#隐式内连接查询<br>select 字段 from 表1,表2 where 表一.字段名 运算符 表二.字段名;<br>#显示内连接<br>select 字段 from 表1 [inner] join 表2 on 条件;<br>#注意<br>从哪些表中查询数据、查询条件是什么、查询哪些字段</li>\n</ol>\n</li>\n<li><p>外连接查询</p>\n<ol>\n<li><p>左外连接：查询的是左表所有数据以及其交集部分</p>\n</li>\n<li><p>右外连接：查询的是右表所有数据以及其交集部分</p>\n<pre><code class=\"sql\">#左外连接\nselect 字段列表 from 表1 left [outer] join 表2 on 条件;\n#右外连接\nselect 字段列表 from 表1 right [outer] join 表2 on 条件;\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>子查询</p>\n<p>概念： 查询中嵌套查询，称嵌套查询为子查询</p>\n<p>分类：</p>\n<ol>\n<li><p>子查询的结果是单行单列的：</p>\n<pre><code class=\"sql\">子查询可以作为条件 使用运算符去判断\nselect 字段列表 from 表名 where 字段 运算符 (子查询语句);\n</code></pre>\n</li>\n<li><p>子查询的结果是多行单列的；</p>\n<pre><code class=\"sql\">select 字段列表 from 表名 where 字段 in (子查询语句);\n</code></pre>\n</li>\n<li><p>子查询的结果是多行多列的。</p>\n<p>子查询可以作为一张虚拟表，起一个别名</p>\n<pre><code class=\"sql\">select 字段列表 from 表1 别名,(子查询语句) 别名 where 条件;\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"事务的基本介绍\"><a href=\"#事务的基本介绍\" class=\"headerlink\" title=\"事务的基本介绍\"></a>事务的基本介绍</h3><p>概念：如果一个包含多个步骤的业务操作，被事务管理，要么同时成功，要么同时失败。</p>\n<p>操作：</p>\n<pre><code>1. 开启事务：start transaction\n1. 回滚：rollback\n1. 提交：commit\n</code></pre>\n<p>MyQL数据库中事务默认自动提交。开启事务后需要手动提交。Oracle默认是手动提交</p>\n<p>修改事务的默认提交方式：</p>\n<p>select @@autocommit; – 0是手动提交 1是自动提交</p>\n<p>set @@autocommit &#x3D; 对应数值;</p>\n<h3 id=\"事务的四大特征\"><a href=\"#事务的四大特征\" class=\"headerlink\" title=\"事务的四大特征\"></a>事务的四大特征</h3><ul>\n<li>原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败</li>\n<li>持久性：如果事务一旦提交或者回滚后，数据库会持久化的保存数据。</li>\n<li>隔离性：多个事务之间，相互独立</li>\n<li>一致性：事务操作前后，数据总量不变。</li>\n</ul>\n<h3 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h3><p>概念：多个事务之间是隔离，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</p>\n<p>存在问题：</p>\n<pre><code>1. 脏读：一个事务，读取到另一个事务中没有提交的数据\n1. 不可重复读：在同一个事务中，两次读取到的数据不一样\n1. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改\n</code></pre>\n<p>隔离级别：</p>\n<ol>\n<li><p>read uncommitted：读未提交</p>\n<p>产生的问题：脏读、不可重复读、幻读</p>\n</li>\n<li><p>read committed：读已提交（Oracle默认）</p>\n<p>产生的问题：不可重复读、幻读</p>\n</li>\n<li><p>repeatable read：可重复读（MySQL默认）</p>\n<p>产生的：幻读</p>\n</li>\n<li><p>serializable：串行化</p>\n<p>产生的问题：可以解决所有的问题</p>\n</li>\n</ol>\n<p>​\t注意：隔离级别从小到大安全性越来越高，但是效率越来越低</p>\n<p>​\t设置隔离级别:</p>\n<pre><code class=\"sql\">#数据库查询隔离级别\nselect @@tx_isolation\n#数据库设置隔离级别\nset global transaction isolation level 级别字符串;\n</code></pre>\n<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h3 id=\"mysql服务的启动与关闭\"><a href=\"#mysql服务的启动与关闭\" class=\"headerlink\" title=\"mysql服务的启动与关闭\"></a>mysql服务的启动与关闭</h3><p>使用管理员身份在控制台输入</p>\n<p>net start&#x2F;stop mysql</p>\n",
            "tags": [
                "sql"
            ]
        }
    ]
}