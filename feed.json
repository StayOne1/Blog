{
    "version": "https://jsonfeed.org/version/1",
    "title": "Youyi's Blog",
    "description": "尤一的计算机学习之路",
    "home_page_url": "https://stayone1.github.io",
    "items": [
        {
            "id": "https://stayone1.github.io/2022/08/31/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/",
            "url": "https://stayone1.github.io/2022/08/31/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/",
            "title": "JAVA设计模式之装饰模式",
            "date_published": "2022-08-31T15:10:00.000Z",
            "content_html": "<h1 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h1><p>装饰器模式是为了在不改变原有类的结构的前提下，给一个现有的对象拓展新的功能。这种类型的设计模式属于结构性模式，它作为现有类的一个包装。</p>\n<p>这种模式为拓展类提供了新的解决方案，可以不使用继承的方式实现。</p>\n<hr>\n<p>优点：</p>\n<ul>\n<li>可以代替继承，减少子类的数量</li>\n<li>动态增加功能，动态撤销</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>多层装饰比较复杂</li>\n</ul>\n<hr>\n<h2 id=\"装饰模式的基本结构\"><a href=\"#装饰模式的基本结构\" class=\"headerlink\" title=\"装饰模式的基本结构\"></a>装饰模式的基本结构</h2><p>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。</p>\n<p>装饰模式类图如下：</p>\n<p><img src=\"/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg\" alt=\"avatar\"></p>\n<p>装饰模式中的角色有：</p>\n<ul>\n<li>抽象构件(Component) ： 给出一个抽象接口，以规范准备接收附加责任的对象。</li>\n<li>具体构件(ConcreteComponent) : 定义一个将要接收附加责任的类。</li>\n<li>装饰角色(Decerator) : 持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。</li>\n<li>具体装饰(ConcreteDecorator)角色 : 负责给构件对象“贴上”附加的责任。</li>\n</ul>\n<p>源代码：</p>\n<p>抽象构件：</p>\n<pre><code class=\"java\">public interface Component &#123;\n    \n    public void sampleOperation();\n    \n&#125;\n</code></pre>\n<p>具体构件 ：</p>\n<pre><code class=\"java\">public class ConcreteComponent implements Component &#123;\n    @Override\n    public void sampleOperation() &#123;\n        // 写相关的业务代码\n    &#125;\n&#125;\n</code></pre>\n<p>装饰角色：</p>\n<pre><code class=\"java\">public class Decorator implements Component&#123;\n    private Component component;\n    \n    public Decorator(Component component)&#123;\n        this.component = component;\n    &#125;\n\n    @Override\n    public void sampleOperation() &#123;\n        // 委派给构件\n        component.sampleOperation();\n    &#125;\n    \n&#125;\n</code></pre>\n<p>具体装饰角色：</p>\n<pre><code class=\"java\">public class ConcreteDecoratorA extends Decorator &#123;\n\n    public ConcreteDecoratorA(Component component) &#123;\n        super(component);\n    &#125;\n    \n    @Override\n    public void sampleOperation() &#123;　　　　　super.sampleOperation();\n        // 写相关的业务代码\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"齐天大圣的例子\"><a href=\"#齐天大圣的例子\" class=\"headerlink\" title=\"齐天大圣的例子\"></a>齐天大圣的例子</h2><p>类图 ：</p>\n<p><img src=\"/%E9%BD%90%E5%A4%A9%E5%A4%A7%E5%9C%A3.png\" alt=\"avatar\"></p>\n<hr>\n<h2 id=\"装饰模式是Java-I-x2F-O的基本模式\"><a href=\"#装饰模式是Java-I-x2F-O的基本模式\" class=\"headerlink\" title=\"装饰模式是Java I&#x2F;O的基本模式\"></a>装饰模式是Java I&#x2F;O的基本模式</h2><p>由于Java I&#x2F;O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。而如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是Java I&#x2F;O库的基本模式。</p>\n<p>InputStream的对象结构图如下：</p>\n<p><img src=\"/InputStream.png\" alt=\"avatar\"></p>\n<p>根据上图可以看出：</p>\n<ul>\n<li><p>Component：由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</p>\n</li>\n<li><p>ConcreteComponent：由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。</p>\n</li>\n<li><p>Decorator：由FilterInputStream扮演。它实现了InputStream所规定的接口。</p>\n</li>\n<li><p>ConcreteDecorator：由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。</p>\n</li>\n</ul>\n<h2 id=\"BufferedReader\"><a href=\"#BufferedReader\" class=\"headerlink\" title=\"BufferedReader\"></a>BufferedReader</h2><p>类图：</p>\n<p><img src=\"/BufferedReader%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png\" alt=\"avatar\"></p>\n<p>在其设计中Readable是抽象构件，Reader则是一个装饰角色，BufferedReader是具体装饰角色，对Reader对象进行了包装。BufferedReader内定义了readLine、fill等方法，使用字符数组作为缓冲区，进而提高读入速度，同时提供了便捷的toString方法，可以直接返回字符串。</p>\n",
            "tags": []
        }
    ]
}