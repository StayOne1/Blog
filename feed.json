{
    "version": "https://jsonfeed.org/version/1",
    "title": "Youyi's Blog",
    "description": "尤一的计算机学习之路",
    "home_page_url": "https://stayone1.github.io",
    "items": [
        {
            "id": "https://stayone1.github.io/2022/09/16/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E8%B4%A8%E6%95%B0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/",
            "url": "https://stayone1.github.io/2022/09/16/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E8%B4%A8%E6%95%B0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/",
            "title": "数论基础-质数相关基础算法",
            "date_published": "2022-09-16T13:19:00.000Z",
            "content_html": "<h1 id=\"质数\"><a href=\"#质数\" class=\"headerlink\" title=\"质数\"></a>质数</h1><h2 id=\"什么是质数（素数）\"><a href=\"#什么是质数（素数）\" class=\"headerlink\" title=\"什么是质数（素数）\"></a>什么是质数（素数）</h2><p>质数就是一个<strong>大于1</strong>的整数，除了1和它本身以外，不能被其他自然数整除</p>\n<p><em>注意：1、0不是质数 质数是从2开始的</em> </p>\n<h2 id=\"一些简单的性质\"><a href=\"#一些简单的性质\" class=\"headerlink\" title=\"一些简单的性质\"></a>一些简单的性质</h2><ol>\n<li>质数x的约数只有1和x;</li>\n<li>任何一个正整数，要么是质数，要么可以分解为几个质数的积(唯一);</li>\n<li>质数定理 ： 1~n 中有 n&#x2F;lnN 个质数</li>\n</ol>\n<h2 id=\"判定一个数是否是质数\"><a href=\"#判定一个数是否是质数\" class=\"headerlink\" title=\"判定一个数是否是质数\"></a>判定一个数是否是质数</h2><p><em>试除法</em> </p>\n<ol>\n<li><p>最简单的试除法  O(n) </p>\n<p> x的约数只能是1~x,如果x是质数，那么除了1和x不能被其他数整除<br> 很明显这个算法最坏会是O(n)的复杂度，但是显然实际运算不会达到这个复杂度，我们待会儿来分析一下</p>\n<pre><code class=\"c++\">bool is_prime(int n )&#123;\nif(n&lt;2) return false;\nfor(int i=2;i&lt;n;i++)&#123;\n    if(n%i==0)\n        return false;\n&#125;\nreturn true;\n&#125;\n</code></pre>\n</li>\n<li><p>做一些简单的优化 0(n) –&gt; O(sqrt(n))</p>\n<p> 上一个算法整体的思路是正确的，瓶颈在于n的大小，因为它最坏是0(n)的复杂度，那我们考虑优化就要从这个角度入手，看是否能够减少循环判断的次数。</p>\n<p> 然后我们就会发现，其实根本不需要遍历到n-1。我们都知道X &#x3D; sqrt(X)^2 , 那么很明显，当其中一个因数缩小，另外一个因数必然增大。由于我们考虑的是正整数范围，所以不存在因数是分数的情况，也就是说因数不能无限制缩小，最小应该是1。</p>\n<p> 那么我们就只用关注1~sqrt(X) 这个范围，因为另外一半里必然跟前一半一一对应。</p>\n<p> 所以这个算法就优化成了这样</p>\n<pre><code class=\"c++\">bool is_prime(int n )&#123;\nif(n&lt;2) return false;\nfor(int i=2;i&lt; = n/i;i++)&#123;\n    if(n%i==0)\n        return false;\n&#125;\nreturn true;\n&#125;\n</code></pre>\n<p>其实，大家可能已经发现了，其实这个循环的上限不是关键，关键是循环内的判断，因为一旦被整除，其实这个函数就已经返回false了。循环从2开始走，如果有约数，必然在2~sqrt(X)中有约数</p>\n</li>\n</ol>\n<h2 id=\"分解质因数\"><a href=\"#分解质因数\" class=\"headerlink\" title=\"分解质因数\"></a>分解质因数</h2><p>试除法    O(logn) ~ O(sqrt(n))</p>\n<p><strong>算法思想</strong></p>\n<p>使用试除法，当遍历到可以整除的i时，让i循环除n并记录次数，然后输出质因子i和其次数ai</p>\n<p>最后如果n有剩余且大于1，就直接输出n和其次数1</p>\n<p><strong>代码如下:</strong></p>\n<pre><code class=\"c++\">   //从小到大枚举所有数 n中最多只包含一个大于sqrt(n)的质因子\n\n   void divide(int n)&#123;\n    for(int i = 2;i &lt;= n/i;i++)&#123;\n        if(n%i==0)&#123;\n            int s = 0;\n            while(n%i==0)&#123;\n                n/=i;\n                s++;\n            &#125;\n\n            printf(&quot;%d %d\\n&quot;,i,s);\n        &#125;     \n    &#125;\n    if( n &gt; 1) printf(&quot;%d %d\\n&quot;,n,1);\n    puts(&quot;&quot;);\n   &#125;\n</code></pre>\n<p><strong>为什么是这样的？</strong></p>\n<p><code> 首先，我们要知道n中最多只包含一个大于sqrt(n)的质因子，这个可以用反证法来证明，假如说存在两个大于sqrt(n)的质因子，那么两个质因子的一次方乘积就已经大于n了，故至多存在1个大于sqrt(n)的质因子。</code></p>\n<p>我们举一个例子，<code>n=33  </code></p>\n<p><code>33 = 3^1 * 11^1</code> ,也就是33的质因子是3和11，11是大于根号33的</p>\n<p>好，明白了这一点，我们就能明白为什么循环条件是到sqrt(n)，为什么最后还要再判断n&gt;1。我们在不断除质数的过程中其实n已经越来越小了，如果n是1说明已经恰好除尽。否则，就说明n还剩了一个大于根号n的质因子，那么我们直接输出就可以了。</p>\n<hr>\n<p><em>截止现在，我们学习了如何判断一个数是否是质数以及如何将一个数分解成为若干质因子的积</em></p>\n<p><em>那么，假设我现在需要知道1~n中质数的个数，怎么办呢？当然，你可以双层for循环解决，但如果n比较大呢？将近n^2的复杂度是不是有点儿高呢，那怎么办呢？</em></p>\n<p><strong>下面我们就要来说这个问题</strong></p>\n<h2 id=\"筛质数\"><a href=\"#筛质数\" class=\"headerlink\" title=\"筛质数\"></a>筛质数</h2><p><em>筛质数要解决的问题就是快速求出n以内质数的个数</em></p>\n<ol>\n<li><p>朴素筛</p>\n<p><strong>算法思想</strong></p>\n<p>既然用除法作试除法一个一个判断太耗时了，那我们可以反其道而行之，我们不用除法，改用乘法去把每个数的倍数筛掉，因为如果n是x的倍数，那么n必然就不是质数，因为它至少有x这个约数</p>\n<p>我们用这个思想就可以从2开始遍历，把每个数的倍数筛掉。</p>\n<p><strong>具体实现</strong></p>\n<p>在具体的实现中，我们是这么来做的。定义primes[N]存放质数，cnt累加质数的个数，st[N]用来标记一个数是否被筛掉，筛掉为true</p>\n<p>我们开始遍历，首先如果当前这个数没有被筛掉，那么它就是一个质数，我们把它放到primes中，然后累加。</p>\n<p>然后我们将n以内i的所有倍数筛掉</p>\n<p>这样这个算法就完成了</p>\n<pre><code class=\"c++\">//朴素筛 O(nlogn)\nconst int N = 1000010 ;\nint primes[N] , cnt;\nbool st[N] ;\n\nvoid get_primes(int n)&#123;\n for(int i = 2;i&lt;=n;i++)&#123;\n     if(!st[i])&#123;\n         primes[cnt++]=i;\n     &#125;\n     for(int j = i+i;j&lt;=n;j+=i) st[j] = true ;\n &#125;\n&#125;\n</code></pre>\n<p>或许大家已经发现了，是否有一些数被多个i重复筛掉了，这里我们举一个简单的例子：8 &#x3D; 2^3,很显然8会被2、4重复筛。</p>\n<p>接下来我们再来考虑一下如何去进一步的优化</p>\n</li>\n<li><p>埃氏筛法</p>\n<p><strong>优化策略</strong></p>\n<p>其实只需要让n的质因子把n筛掉即可，如果i不是质数就不需要再筛i的倍数，大家可以思考一下。比如8&#x3D;2^3,i&#x3D;2就可以筛掉8，当i&#x3D;4时，i其实是一个合数，就不用筛了，因为4的倍数一定也是2的倍数。</p>\n<pre><code class=\"c++\">//质数定理 ： 1~n 中有 n/lnN 个质数 \n//优化--&gt; O(nloglogn)  \nconst int N = 1000010 ;\nint primes[N] , cnt;\nbool st[N] ;\n\nvoid get_primes(int n)&#123;\n for(int i = 2;i&lt;=n;i++)&#123;\n     if(!st[i])&#123;\n         primes[cnt++]=i;\n         for(int j = i+i;j&lt;=n;j+=i) st[j] = true ;\n     &#125;\n &#125;\n&#125;\n</code></pre>\n<p>那么可能大家又会想到，n会不会被多个质因子重复筛掉呢，想到这里，那博主真的要羡慕的哭出来了，毕竟当时想到这些的都是计算机界的dalao</p>\n<p><strong>线性筛法</strong>就是为了解决这个问题！</p>\n</li>\n<li><p>线性筛法</p>\n<p> <strong>优化策略</strong></p>\n<p> 让每一个合数都只被自己的最小质因子筛掉</p>\n<pre><code class=\"c++\">//线性筛法  10^7\n//n 只会被其最小质因子筛掉\nconst int N = 1000010 ;\nint primes[N] , cnt;\nbool st[N] ;\n\nvoid get_primes(int n)&#123;\n    for(int i = 2;i&lt;=n;i++)&#123;\n        if(!st[i]) primes[cnt++]=i;\n        for(int j = 0;primes[j] &lt;=n / i; j++ )&#123;\n            st[primes[j]*i] = true ;\n            if(i%primes[j] == 0) break; //primes[j]一定是i的最小质因子，\n        &#125;\n    &#125;\n&#125;\n\n分析循环体\n1. i%pj == 0\n    pj一定是i的最小质因子，pj一定是i * pj 的最小质因子\n2. i%pj!=0\n    pj一定小于i的所有质因子，pj也一定是i * pj的最小质因子\n\n所以说一个合数只会被自己的最小质因子筛掉\n</code></pre>\n</li>\n</ol>\n",
            "tags": [
                "算法",
                "数论",
                "质数"
            ]
        },
        {
            "id": "https://stayone1.github.io/2022/09/03/Git%E5%9F%BA%E7%A1%80/",
            "url": "https://stayone1.github.io/2022/09/03/Git%E5%9F%BA%E7%A1%80/",
            "title": "Git基础",
            "date_published": "2022-09-03T01:40:00.000Z",
            "content_html": "<h1 id=\"Git学习\"><a href=\"#Git学习\" class=\"headerlink\" title=\"Git学习\"></a>Git学习</h1><p>Git 是一个分布式版本控制系统，可以便捷高效地处理任何项目。Git的内容存储使用的是SHA-1哈希算法。</p>\n<h2 id=\"Git-工作流程\"><a href=\"#Git-工作流程\" class=\"headerlink\" title=\"Git 工作流程\"></a>Git 工作流程</h2><ul>\n<li>克隆 Git 资源作为工作目录。</li>\n<li>在克隆的资源上添加或修改文件。</li>\n<li>如果其他人修改了，你可以更新资源。</li>\n<li>在提交前查看修改。</li>\n<li>提交修改。</li>\n<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>\n</ul>\n<img src = \"git工作流程.png\">\n\n<h2 id=\"Git工作区、暂存区、版本库\"><a href=\"#Git工作区、暂存区、版本库\" class=\"headerlink\" title=\"Git工作区、暂存区、版本库\"></a>Git工作区、暂存区、版本库</h2><ul>\n<li><strong>工作区：</strong> 就是你在电脑里能看到的目录</li>\n<li><strong>暂存区：</strong> (index) 一般存放在.git目录下的index文件中，也叫做索引</li>\n<li><strong>版本库：</strong> 工作区一个隐藏目录.git</li>\n</ul>\n<img src = \"git三区.jpg\">\n\n<hr>\n<h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><ul>\n<li><p>创建文件夹</p>\n<p> <code>mkdir 文件夹名</code> </p>\n</li>\n<li><p>切换到某目录下</p>\n<p> <code>cd 文件夹名</code> </p>\n</li>\n<li><p>查看当前目录</p>\n<p> <code>pwd</code></p>\n</li>\n<li><p>把当前目录初始化到仓库</p>\n<p> <code>git init</code> </p>\n</li>\n<li><p>添加文件到仓库 可以添加多个文件</p>\n<p> <code>git add 文件名</code></p>\n</li>\n<li><p>提交到仓库</p>\n<p> <code>git commit -m &quot;解释&quot;</code></p>\n</li>\n</ul>\n<h2 id=\"时光机\"><a href=\"#时光机\" class=\"headerlink\" title=\"时光机\"></a>时光机</h2><ul>\n<li>当前仓库状态(本地)<br> <code>git status</code> </li>\n<li>查看文件上次修改记录<br> <code>git diff 文件名</code></li>\n</ul>\n<h3 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h3><ul>\n<li>显示最近到最远的提交日志<br> <code>git log</code> </li>\n<li>简易显示<br> <code>git log --pretty=oneline</code></li>\n</ul>\n<blockquote>\n<p>HEAD表示当前版本，HEAD^表示上一版本</p>\n<p>HEAD^^表示上上版本，HEAD~100表示上100个版本</p>\n</blockquote>\n<ul>\n<li><p>HEAD也可以换成是对应版本的前部分版本号</p>\n<p> <code>git reset --hard HEAD^</code> </p>\n</li>\n<li><p>记录了每一次命令</p>\n<p> <code>git reflog</code></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"连接远程仓库\"><a href=\"#连接远程仓库\" class=\"headerlink\" title=\"连接远程仓库\"></a>连接远程仓库</h2><ol>\n<li><p>生成ssh密钥</p>\n<pre><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot; \n</code></pre>\n<p> 生成的密钥默认位于C:\\Users\\用户名.ssh文件夹中 默认文件名为id_rsa</p>\n</li>\n<li><p>建立与github的连接</p>\n<p>进入用户settings ，选择ssh and GPG keys,创建一个ssh密钥，把公钥(.pub)粘贴进去</p>\n</li>\n<li><p>连接远程仓库</p>\n<p>在github中创建项目仓库，并复制仓库ssh链接  通常为<code>git@github.com:xxx/xxx.git</code></p>\n<p>在本地仓库进入git bash ，运行命令<code>git remote add origin git@github.com:xxx/xxx.git</code></p>\n</li>\n<li><p>pull操作</p>\n<p><code>git pull --rebase origin 分支名</code></p>\n</li>\n<li><p>push操作</p>\n<p><code>git push -u origin 分支名</code></p>\n</li>\n</ol>\n",
            "tags": [
                "Git"
            ]
        },
        {
            "id": "https://stayone1.github.io/2022/09/01/sql/",
            "url": "https://stayone1.github.io/2022/09/01/sql/",
            "title": "SQL",
            "date_published": "2022-09-01T11:07:00.000Z",
            "content_html": "<p><em>这个主要是整理之前学习时的笔记 持续更新 欢迎大家留言 批评指正</em></p>\n<h1 id=\"SQL\"><a href=\"#SQL\" class=\"headerlink\" title=\"SQL\"></a>SQL</h1><h2 id=\"SQL通用语法\"><a href=\"#SQL通用语法\" class=\"headerlink\" title=\"SQL通用语法\"></a>SQL通用语法</h2><ol>\n<li><p>SQL语句可以单行或多行书写，以分号结尾。</p>\n</li>\n<li><p>可以使用空格和缩进提高可读性。</p>\n</li>\n<li><p>MySQL中SQL语句不区分大小写，关键字建议大写。</p>\n</li>\n<li><p>3种注释</p>\n<ul>\n<li><p>单行注释</p>\n<pre><code class=\"sql\">-- 注释内容\n# 注释内容\n</code></pre>\n</li>\n<li><p>多行注释</p>\n<pre><code class=\"sql\">/*\n注释\n*/\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"DDL语句\"><a href=\"#DDL语句\" class=\"headerlink\" title=\"DDL语句\"></a>DDL语句</h2><p>DDL（Data Definition Language）数据定义语言，用来定义数据库对象“数据库，表，列等。关键字：create,drop,alter等</p>\n<ol>\n<li><p>操作数据库：CRUD</p>\n<ol>\n<li><p>C(Create):创建</p>\n</li>\n<li><p>R(Retrieve):查询</p>\n</li>\n<li><p>U(Update):修改</p>\n</li>\n<li><p>D(Delete):删除</p>\n</li>\n<li><p>使用数据库</p>\n<pre><code class=\"sql\">#创建\n基本创建\ncreate database 数据库名;\n如果不存在，再进行创建\ncreate database if not exists 数据库名;\n指定字符集\ncreate database 数据库名 character set 字符集;\n\n#查询\n查询所有数据库的名称\nshow databases;\n查看某数据库创建语句\nshow create database 数据库名称;\n\n#修改\n修改数据库的字符集\nalter database 数据库名 character set 字符集名;\n\n#删除\n删除数据库\ndrop database 数据库名称;\n判断是否存在\ndrop database if exists 数据库名字;\n\n#使用\n查询当前正在使用的数据库\nselect database();\n切换到对应数据库\nuse 数据库名;\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>操作表：CRUD</p>\n<pre><code class=\"SQL\">#创建\n创建表\ncreate table 表名(\n    列名1 数据类型1,\n    列名2 数据类型2,\n    ...\n    列名n 数据类型n\n);\n复制表\ncreate table 表名 like 表名;\n#查询\n查询某个数据库中所有的表名称\nshow tables;\n查询表结构\ndesc 表名;\n#修改\n修改表名\nalter table 表名 rename to 新表名;\n修改表的字符集\nalter table 表名 character set 字符集;\n添加列\nalter table 表名 add 列名 数据类型;\n修改列名、类型\nalter table 表名 change 列名 新列名 类型;\n只修改列类型\nalter table 表名 modify 列名 列类型;\n删除列\nalter table 表名 drop 列名;\n#删除\ndrop table 表名;\ndrop table if exists 表名;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"DQL语句\"><a href=\"#DQL语句\" class=\"headerlink\" title=\"DQL语句\"></a>DQL语句</h2><p>DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录。关键字：select,where等</p>\n<ul>\n<li>基础查询  字段名后可以加 [AS] 别名</li>\n<li>条件查询  条件运算符 between … and …    and   or</li>\n<li>分组查询  </li>\n<li>排序查询  升序ASC 降序DESC</li>\n<li>分页查询 起始索引（从0开始），每页展示记录数</li>\n</ul>\n<ol>\n<li><p>基础查询</p>\n<ol>\n<li><p>多个字段的查询</p>\n</li>\n<li><p>去除重复</p>\n</li>\n<li><p>计算列</p>\n</li>\n<li><p>起别名</p>\n<pre><code class=\"sql\">#多个字段的查询\nselect 字段1,字段2,...,字段n from 表名;\nselect * from 表名;\n#去除重复\nselect distinct 字段名 from 表名;\n#计算列，数值型\nselect 字段1,字段2,字段1+字段2 from 表名;\nselect 字段1,字段2,字段1+IFNULL(字段2,0) from 表名; //当某字段值为null时\n#起别名\nselect 字段1,字段2,字段1+IFNULL(字段2,0) AS(可以省略) 总分 from 表名; \n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>条件查询</p>\n<ol>\n<li><p>where 子句后跟条件</p>\n</li>\n<li><p>运算符</p>\n<pre><code class=\"sql\">#where\nselect 字段名 from 表名 where 条件;\n#运算符\n&lt; &gt; &lt;= &gt;= == &lt;&gt;(!=)\nbetween and \nlike\nis null\nand 或 &amp;&amp;\nor 或 ||\nnot 或 !\nin\n#注意\nNULL值不能使用运算符判断  要用is\nwhere 字段名 is null\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>模糊查询</p>\n<pre><code class=\"sql\">#占位符\n_:单个任意字符\n%:多个任意字符\n#语法\nselect 字段 from 表名 where 字段名 like ;\n</code></pre>\n</li>\n<li><p>排序查询</p>\n<pre><code class=\"sql\">#语法\norder by 排序字段1 排序方式1,...,排序字段n 排序方式n;\n排序方式省略时默认按照升序排序\n#排序方式\nASC：升序，默认\nDESC：降序\n#多字段优先级\n语句前面的字段更优先\n</code></pre>\n</li>\n<li><p>聚合函数(将一列数据纵向计算)</p>\n<ol>\n<li><p>count:计算个数</p>\n</li>\n<li><p>max:计算最大值</p>\n</li>\n<li><p>min:计算最小值</p>\n</li>\n<li><p>sum:求和</p>\n</li>\n<li><p>avg:平均值</p>\n<pre><code class=\"sql\">#count\nselect count(*) from 表名;\nselect count(字段名) from 表名;\n字段可以使用IFNULL转换\n#max\nselect max(字段名) from 表名;\n#min\nselect min(字段名) from 表名;\n#sum\nselect sum(字段名) from 表名;\n#avg\n#注意\n聚合函数的计算，排除NULL值\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>分组查询</p>\n<pre><code class=\"sql\">#语法\ngroup by 分组字段;\n#注意\n分组之后查询的字段：分组字段、聚合函数\n#分组前过滤，即不参与分组\nselect 字段 from 表名 where 条件 group by 字段;\n#分组后过滤\nselect 字段 from 表名 group by 字段 having 条件;\n\n#where 和 having 的区别\nwhere 在分组之前进行限定，如果不满足条件，则不参与分组。 having 在分组之后进行限定，如果不满足结果，则不会被查询出来。\nwhere 后不可以跟聚合函数，having可以进行聚合函数的判断\n</code></pre>\n</li>\n<li><p>分页查询</p>\n<pre><code class=\"sql\">#语法\nlimit 开始的索引,每页查询的条数;\n#公式\n开始的索引 = (当前页码-1)*每页显示的条数\n#分页操作是一个方言，不同数据库存在区别\nlimit是mysql的\n</code></pre>\n</li>\n</ol>\n<h3 id=\"DQL-编写顺序\"><a href=\"#DQL-编写顺序\" class=\"headerlink\" title=\"DQL-编写顺序\"></a>DQL-编写顺序</h3><pre><code class=\"sql\">SELECT\n      字段列表\nFROM\n      表名列表\nWHERE\n      条件列表 #分组之前过滤\nGROUP BY\n      分组字段列表\nHAVING\n      分组后条件列表 #分组之后过滤\nORDER BY \n      排序字段列表\nLIMIT\n      分页参数\n</code></pre>\n<hr>\n<h3 id=\"DQL-执行顺序\"><a href=\"#DQL-执行顺序\" class=\"headerlink\" title=\"DQL-执行顺序\"></a>DQL-执行顺序</h3><pre><code class=\"sql\">FROM\n      表名列表\nWHERE\n      条件列表\nGROUP BY\n      分组字段列表\nHAVING\n      分组后条件列表\nSELECT\n      字段列表\nORDER BY\n      排序字段列表\nLIMIT\n      分页参数\n</code></pre>\n<h2 id=\"DCL语句\"><a href=\"#DCL语句\" class=\"headerlink\" title=\"DCL语句\"></a>DCL语句</h2><ul>\n<li><p>DCL-介绍</p>\n<p>DCL-数据控制语言，用来管理数据库用户以及用户对数据库的访问权限,关键字：GRANT,REVOKE等</p>\n</li>\n<li><p>DCL-管理用户</p>\n<ul>\n<li><p>查询用户</p>\n<pre><code class=\"sql\">USE mysql; \nSELLECT * FROM user;\n#注意\n%指可以在任意主机登录\n</code></pre>\n</li>\n<li><p>创建用户</p>\n<pre><code class=\"sql\">CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;\n</code></pre>\n</li>\n<li><p>修改用户密码</p>\n<pre><code class=\"sql\">ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password by &#39;新密码&#39;;\n#root改其它\nupdate user set password = password(&#39;新密码&#39;) where user = &#39;用户名&#39;;\nset password for &#39;用户名&#39;@&#39;主机名&#39; = password(&#39;新密码&#39;);\n#mysql 忘记root密码\n1. cmd -- &gt; net stop mysql  //管理员\n2. 使用无验证方式启动Mysql服务  mysqld --skip-grant-tables\n3. 新开cmd然后直接输入mysql 回车 无验证登录后修改密码\n4. 任务管理器结束mysqld进程\n5. 打开mysql服务 net start mysql\n6. 正常登录\n</code></pre>\n</li>\n<li><p>删除用户</p>\n<pre><code class=\"sql\">DROP USER &#39;用户名&#39;@&#39;主机名&#39;;\n#权限说明\nusage ： 可以登录\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>DCL-授权</p>\n<ul>\n<li><p>查询权限</p>\n<pre><code class=\"sql\">show grants for &#39;用户名&#39;@&#39;主机名&#39;;\n</code></pre>\n</li>\n<li><p>授予权限</p>\n<pre><code class=\"sql\">grant 权限列表 on 数据库.表名 to &#39;用户名&#39;@&#39;主机名&#39;;\n#授予所有权限\ngrant all on *.* to &#39;用户名&#39;@&#39;主机名&#39;;\n</code></pre>\n</li>\n<li><p>撤销权限</p>\n<pre><code class=\"sql\">revoke 权限列表 on 数据库.表名 from &#39;用户名&#39;@&#39;主机名&#39;;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>DBA：数据库管理员</p>\n</li>\n</ul>\n<h2 id=\"DML语句\"><a href=\"#DML语句\" class=\"headerlink\" title=\"DML语句\"></a>DML语句</h2><p>DML(Data Manipulation Language)数据操作语言 用来对表中的数据进行增删查改。关键字：insert,delete,update等</p>\n<ol>\n<li><p>添加数据</p>\n</li>\n<li><p>删除数据</p>\n</li>\n<li><p>修改数据</p>\n<pre><code class=\"sql\">#添加数据\ninsert into 表名(列名1,列名2,...,列名n) values(值1,值2,...,值n);\n列名要和值一一对应\n如果不指定列名，则默认给所有列添加值\n除了数字，其他都要用引号引起来，单双引号都可以\n\n#删除数据\ndelete from 表名 [where 条件];\n如果不加条件，则删除表中所有的记录\n如果要删除表中所有记录，有两种方式。不推荐使用delete，效率低。建议使用后者。\n\n删除表，然后再创建一个一模一样的空表\nTRUNCATE TABLE 表名;\n\n#修改数据\nupdate 表名 set 列名1 = 值1,... [where 条件];\n如果不加任何条件，则会修改所有记录\n</code></pre>\n</li>\n</ol>\n<h2 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h2><p>概念 ： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。</p>\n<p>分类 ： </p>\n<ol>\n<li><p>主键约束：primary key</p>\n</li>\n<li><p>非空约束：not null</p>\n</li>\n<li><p>唯一约束：unique</p>\n</li>\n<li><p>外键约束：foreign key</p>\n<pre><code class=\"sql\">#主键约束,非空且唯一，一张表只能有一个主键\n主键即表中记录的唯一标识\n\n创建表时添加约束\nCreate table stu&#123;\n    id int primary key,\n    name varchar(10) \n&#125;;\n创建表后添加约束\nalter table 表名 modify 字段名 字段类型 primary key;\n删除约束\nalter table 表名 drop primary key;\n自动增长，如果某一列是数值类型，可以使用auto_increment 可以自动增长\n创建表时添加约束，并使其自动增长\nCreate table stu&#123;\n    id int primary key auto_increment,\n    name varchar(10) \n&#125;;\n删除自动增长，并不会删除主键\nalter table 表名 modify 字段名 字段类型;\n添加自动增长\nalter table 表名 modify 字段名 字段类型 auto_increment;\n\n#非空约束\n创建表时添加约束\nCreate table stu&#123;\n    id int,\n    name varchar(10) not null\n&#125;;\n创建表后添加非空约束\nalter table 表名 modify 字段名 字段类型 not null;\n删除非空约束\nalter table 表名 modify 字段名 字段类型;\n\n#唯一约束,值不能重复\n创建表时添加约束\nCreate table stu&#123;\n    id int,\n    name varchar(10) unique\n&#125;;\n创建表后添加约束\nalter table 表名 modify 字段名 字段类型 unique;\n删除约束\nalter table 表名 drop index 字段名;\n注意\n唯一约束可以有null，但只能有一个为null\n\n#外键约束,让表与表产生关系\n创建表时，可以添加外键\ncreate table 表名&#123;\n    ...\n    外键列,\n    constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)\n&#125;;\n删除外键\nalter table 表名 drop foreign key 外键名称;\n创建表后，添加外键\nalter table 表名 add constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称);\n\n#级联\n添加外键，设置级联更新\nalter table 表名 add constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) on update cascade;\n设置级联删除\non delete cascade\n</code></pre>\n</li>\n</ol>\n<h2 id=\"数据库的设计\"><a href=\"#数据库的设计\" class=\"headerlink\" title=\"数据库的设计\"></a>数据库的设计</h2><h3 id=\"多表关系\"><a href=\"#多表关系\" class=\"headerlink\" title=\"多表关系\"></a>多表关系</h3><ol>\n<li><p>一对一(了解)</p>\n<p>如：人和身份证</p>\n<p>分析：一个人只有一个身份证，一个身份证只能对应一个人</p>\n</li>\n<li><p>一对多(多对一)</p>\n<p>如：部门和员工</p>\n<p>分析：一个部门有多个员工，一个员工只能对应一个部门</p>\n</li>\n<li><p>多对多</p>\n<p>如：学生和课程</p>\n<p>分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择</p>\n</li>\n</ol>\n<pre><code class=\"sql\">#实现\n\n#一对多关系实现\n设计两个表，使用外键实现。在多的一方建立外键，指向一的一方的主键。\n#实现多对多关系\n借助第三张表，中间表(t_xx_xx)。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。\n#一对一关系\n任意一方建立外键，指向另一方的主键。外键添加唯一约束。\n</code></pre>\n<h3 id=\"数据库设计的范式\"><a href=\"#数据库设计的范式\" class=\"headerlink\" title=\"数据库设计的范式\"></a>数据库设计的范式</h3><p>概念：设计数据库时，需要遵循的一些规范。各种范式呈递次规范，越高的范式数据库冗余越小。要遵循后边的范式，必须先遵循前边的所有范式要求。</p>\n<p>目前关系数据库有六种范式：第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)、第五范式(5NF)</p>\n<p>分类：</p>\n<ol>\n<li><p>第一范式：每一列都是不可分割的原子数据项。</p>\n<p>存在的问题：</p>\n<ul>\n<li><p>存在严重的数据冗余</p>\n</li>\n<li><p>数据添加时存在问题</p>\n</li>\n<li><p>删除数据时存在问题</p>\n</li>\n</ul>\n</li>\n<li><p>第二范式：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</p>\n<p>概念：</p>\n<ul>\n<li>函数依赖：A–&gt;B，如果通过A属性(属性组)的值，可以确定唯一B属性的值，则称B依赖于A<ul>\n<li>学号 –&gt; 姓名  </li>\n<li>(学号，课程名称) –&gt; 分数</li>\n</ul>\n</li>\n<li>完全函数依赖：A –&gt; B ，如果A是一个属性组，则B属性值的确定需要依赖A属性组中所有属性的值<ul>\n<li>(学号，课程名称) –&gt; 分数</li>\n</ul>\n</li>\n<li>部分函数依赖：A–&gt;B ，如果A是一个属性组，则B属性值只需要依赖A中某一些值即可<ul>\n<li>(学号，课程名称) –&gt; 姓名</li>\n</ul>\n</li>\n<li>传递函数依赖：A–&gt;B B–&gt;C   如果通过A属性(属性组)的值，可以确定唯一B属性的值，再通过B属性(属性组)的值，可以确定唯一C属性的值，则称C传递函数依赖于A</li>\n<li>码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码。<ul>\n<li>(学号，课程名称)</li>\n</ul>\n</li>\n<li>主属性：码属性组中的所有属性</li>\n<li>非主属性：除码属性组的属性</li>\n</ul>\n</li>\n</ol>\n<p>​\t3. 第三范式：在2NF的基础上，任何非主属性不依赖于其他非主属性(在2NF基础上消除传递依赖)</p>\n<h2 id=\"数据库的备份和还原\"><a href=\"#数据库的备份和还原\" class=\"headerlink\" title=\"数据库的备份和还原\"></a>数据库的备份和还原</h2><ol>\n<li><p>命令行方式</p>\n<pre><code class=\"sql\">#备份\nmysqldump -u用户名 -p密码 数据库名 &gt; 保存的路径    //路径包含文件名后缀\n#还原\n登录\n创建数据库\n使用数据库\n执行文件 source 文件路径\n</code></pre>\n</li>\n<li><p>图形化工具</p>\n</li>\n</ol>\n<h2 id=\"多表查询\"><a href=\"#多表查询\" class=\"headerlink\" title=\"多表查询\"></a>多表查询</h2><p>笛卡尔积</p>\n<ol>\n<li><p>内连接查询</p>\n<ol>\n<li>隐式内连接：使用where条件消除无用数据</li>\n<li>显式内连接：<br>&#96;&#96;&#96; sql<br>#隐式内连接查询<br>select 字段 from 表1,表2 where 表一.字段名 运算符 表二.字段名;<br>#显示内连接<br>select 字段 from 表1 [inner] join 表2 on 条件;<br>#注意<br>从哪些表中查询数据、查询条件是什么、查询哪些字段</li>\n</ol>\n</li>\n<li><p>外连接查询</p>\n<ol>\n<li><p>左外连接：查询的是左表所有数据以及其交集部分</p>\n</li>\n<li><p>右外连接：查询的是右表所有数据以及其交集部分</p>\n<pre><code class=\"sql\">#左外连接\nselect 字段列表 from 表1 left [outer] join 表2 on 条件;\n#右外连接\nselect 字段列表 from 表1 right [outer] join 表2 on 条件;\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>子查询</p>\n<p>概念： 查询中嵌套查询，称嵌套查询为子查询</p>\n<p>分类：</p>\n<ol>\n<li><p>子查询的结果是单行单列的：</p>\n<pre><code class=\"sql\">子查询可以作为条件 使用运算符去判断\nselect 字段列表 from 表名 where 字段 运算符 (子查询语句);\n</code></pre>\n</li>\n<li><p>子查询的结果是多行单列的；</p>\n<pre><code class=\"sql\">select 字段列表 from 表名 where 字段 in (子查询语句);\n</code></pre>\n</li>\n<li><p>子查询的结果是多行多列的。</p>\n<p>子查询可以作为一张虚拟表，起一个别名</p>\n<pre><code class=\"sql\">select 字段列表 from 表1 别名,(子查询语句) 别名 where 条件;\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"事务的基本介绍\"><a href=\"#事务的基本介绍\" class=\"headerlink\" title=\"事务的基本介绍\"></a>事务的基本介绍</h3><p>概念：如果一个包含多个步骤的业务操作，被事务管理，要么同时成功，要么同时失败。</p>\n<p>操作：</p>\n<pre><code>1. 开启事务：start transaction\n1. 回滚：rollback\n1. 提交：commit\n</code></pre>\n<p>MyQL数据库中事务默认自动提交。开启事务后需要手动提交。Oracle默认是手动提交</p>\n<p>修改事务的默认提交方式：</p>\n<p>select @@autocommit; – 0是手动提交 1是自动提交</p>\n<p>set @@autocommit &#x3D; 对应数值;</p>\n<h3 id=\"事务的四大特征\"><a href=\"#事务的四大特征\" class=\"headerlink\" title=\"事务的四大特征\"></a>事务的四大特征</h3><ul>\n<li>原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败</li>\n<li>持久性：如果事务一旦提交或者回滚后，数据库会持久化的保存数据。</li>\n<li>隔离性：多个事务之间，相互独立</li>\n<li>一致性：事务操作前后，数据总量不变。</li>\n</ul>\n<h3 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h3><p>概念：多个事务之间是隔离，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</p>\n<p>存在问题：</p>\n<pre><code>1. 脏读：一个事务，读取到另一个事务中没有提交的数据\n1. 不可重复读：在同一个事务中，两次读取到的数据不一样\n1. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改\n</code></pre>\n<p>隔离级别：</p>\n<ol>\n<li><p>read uncommitted：读未提交</p>\n<p>产生的问题：脏读、不可重复读、幻读</p>\n</li>\n<li><p>read committed：读已提交（Oracle默认）</p>\n<p>产生的问题：不可重复读、幻读</p>\n</li>\n<li><p>repeatable read：可重复读（MySQL默认）</p>\n<p>产生的：幻读</p>\n</li>\n<li><p>serializable：串行化</p>\n<p>产生的问题：可以解决所有的问题</p>\n</li>\n</ol>\n<p>​\t注意：隔离级别从小到大安全性越来越高，但是效率越来越低</p>\n<p>​\t设置隔离级别:</p>\n<pre><code class=\"sql\">#数据库查询隔离级别\nselect @@tx_isolation\n#数据库设置隔离级别\nset global transaction isolation level 级别字符串;\n</code></pre>\n<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h3 id=\"mysql服务的启动与关闭\"><a href=\"#mysql服务的启动与关闭\" class=\"headerlink\" title=\"mysql服务的启动与关闭\"></a>mysql服务的启动与关闭</h3><p>使用管理员身份在控制台输入</p>\n<p>net start&#x2F;stop mysql</p>\n",
            "tags": [
                "sql"
            ]
        },
        {
            "id": "https://stayone1.github.io/2022/08/31/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/",
            "url": "https://stayone1.github.io/2022/08/31/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/",
            "title": "JAVA设计模式之装饰模式",
            "date_published": "2022-08-31T15:10:00.000Z",
            "content_html": "<h1 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h1><p>装饰器模式是为了在不改变原有类的结构的前提下，给一个现有的对象拓展新的功能。这种类型的设计模式属于结构性模式，它作为现有类的一个包装。</p>\n<p>这种模式为拓展类提供了新的解决方案，可以不使用继承的方式实现。</p>\n<hr>\n<p>优点：</p>\n<ul>\n<li>可以代替继承，减少子类的数量</li>\n<li>动态增加功能，动态撤销</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>多层装饰比较复杂</li>\n</ul>\n<hr>\n<h2 id=\"装饰模式的基本结构\"><a href=\"#装饰模式的基本结构\" class=\"headerlink\" title=\"装饰模式的基本结构\"></a>装饰模式的基本结构</h2><p>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。</p>\n<p>装饰模式类图如下：</p>\n<img src=\"装饰模式基本结构.jpg\">\n\n<p>装饰模式中的角色有：</p>\n<ul>\n<li>抽象构件(Component) ： 给出一个抽象接口，以规范准备接收附加责任的对象。</li>\n<li>具体构件(ConcreteComponent) : 定义一个将要接收附加责任的类。</li>\n<li>装饰角色(Decerator) : 持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。</li>\n<li>具体装饰(ConcreteDecorator)角色 : 负责给构件对象“贴上”附加的责任。</li>\n</ul>\n<p>源代码：</p>\n<p>抽象构件：</p>\n<pre><code class=\"java\">public interface Component &#123;\n    \n    public void sampleOperation();\n    \n&#125;\n</code></pre>\n<p>具体构件 ：</p>\n<pre><code class=\"java\">public class ConcreteComponent implements Component &#123;\n    @Override\n    public void sampleOperation() &#123;\n        // 写相关的业务代码\n    &#125;\n&#125;\n</code></pre>\n<p>装饰角色：</p>\n<pre><code class=\"java\">public class Decorator implements Component&#123;\n    private Component component;\n    \n    public Decorator(Component component)&#123;\n        this.component = component;\n    &#125;\n\n    @Override\n    public void sampleOperation() &#123;\n        // 委派给构件\n        component.sampleOperation();\n    &#125;\n    \n&#125;\n</code></pre>\n<p>具体装饰角色：</p>\n<pre><code class=\"java\">public class ConcreteDecoratorA extends Decorator &#123;\n\n    public ConcreteDecoratorA(Component component) &#123;\n        super(component);\n    &#125;\n    \n    @Override\n    public void sampleOperation() &#123;　　　　　super.sampleOperation();\n        // 写相关的业务代码\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"齐天大圣的例子\"><a href=\"#齐天大圣的例子\" class=\"headerlink\" title=\"齐天大圣的例子\"></a>齐天大圣的例子</h2><p>类图 ：</p>\n<img src=\"齐天大圣.png\">\n\n<hr>\n<h2 id=\"装饰模式是Java-I-x2F-O的基本模式\"><a href=\"#装饰模式是Java-I-x2F-O的基本模式\" class=\"headerlink\" title=\"装饰模式是Java I&#x2F;O的基本模式\"></a>装饰模式是Java I&#x2F;O的基本模式</h2><p>由于Java I&#x2F;O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。而如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是Java I&#x2F;O库的基本模式。</p>\n<p>InputStream的对象结构图如下：</p>\n<img src=\"InputStream.png\">\n\n<p>根据上图可以看出：</p>\n<ul>\n<li><p>Component：由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</p>\n</li>\n<li><p>ConcreteComponent：由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。</p>\n</li>\n<li><p>Decorator：由FilterInputStream扮演。它实现了InputStream所规定的接口。</p>\n</li>\n<li><p>ConcreteDecorator：由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。</p>\n</li>\n</ul>\n<h2 id=\"BufferedReader\"><a href=\"#BufferedReader\" class=\"headerlink\" title=\"BufferedReader\"></a>BufferedReader</h2><p>类图：</p>\n<img src=\"BufferedReader设计模式类图.png\">\n\n<p>在其设计中Readable是抽象构件，Reader则是一个装饰角色，BufferedReader是具体装饰角色，对Reader对象进行了包装。BufferedReader内定义了readLine、fill等方法，使用字符数组作为缓冲区，进而提高读入速度，同时提供了便捷的toString方法，可以直接返回字符串。</p>\n<hr>\n<p>参考文章：</p>\n<p><a href=\"https://www.jianshu.com/p/d7f20ae63186\">设计模式详解——装饰者模式</a></p>\n<p><a href=\"https://www.runoob.com/design-pattern/decorator-pattern.html\">菜鸟教程</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_43767015/article/details/119991474\">刘java</a></p>\n",
            "tags": [
                "设计模式",
                "JAVA"
            ]
        }
    ]
}