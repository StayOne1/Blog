{
    "version": "https://jsonfeed.org/version/1",
    "title": "Youyi's Blog • All posts by \"算法\" tag",
    "description": "尤一的计算机学习之路",
    "home_page_url": "https://stayone1.github.io",
    "items": [
        {
            "id": "https://stayone1.github.io/2022/09/16/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E8%B4%A8%E6%95%B0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/",
            "url": "https://stayone1.github.io/2022/09/16/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E8%B4%A8%E6%95%B0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/",
            "title": "数论基础-质数相关基础算法",
            "date_published": "2022-09-16T13:19:00.000Z",
            "content_html": "<h1 id=\"质数\"><a href=\"#质数\" class=\"headerlink\" title=\"质数\"></a>质数</h1><h2 id=\"什么是质数（素数）\"><a href=\"#什么是质数（素数）\" class=\"headerlink\" title=\"什么是质数（素数）\"></a>什么是质数（素数）</h2><p>质数就是一个<strong>大于1</strong>的整数，除了1和它本身以外，不能被其他自然数整除</p>\n<p><em>注意：1、0不是质数 质数是从2开始的</em> </p>\n<h2 id=\"一些简单的性质\"><a href=\"#一些简单的性质\" class=\"headerlink\" title=\"一些简单的性质\"></a>一些简单的性质</h2><ol>\n<li>质数x的约数只有1和x;</li>\n<li>任何一个正整数，要么是质数，要么可以分解为几个质数的积(唯一);</li>\n<li>质数定理 ： 1~n 中有 n&#x2F;lnN 个质数</li>\n</ol>\n<h2 id=\"判定一个数是否是质数\"><a href=\"#判定一个数是否是质数\" class=\"headerlink\" title=\"判定一个数是否是质数\"></a>判定一个数是否是质数</h2><p><em>试除法</em> </p>\n<ol>\n<li><p>最简单的试除法  O(n) </p>\n<p> x的约数只能是1~x,如果x是质数，那么除了1和x不能被其他数整除<br> 很明显这个算法最坏会是O(n)的复杂度，但是显然实际运算不会达到这个复杂度，我们待会儿来分析一下</p>\n<pre><code class=\"c++\">bool is_prime(int n )&#123;\nif(n&lt;2) return false;\nfor(int i=2;i&lt;n;i++)&#123;\n    if(n%i==0)\n        return false;\n&#125;\nreturn true;\n&#125;\n</code></pre>\n</li>\n<li><p>做一些简单的优化 0(n) –&gt; O(sqrt(n))</p>\n<p> 上一个算法整体的思路是正确的，瓶颈在于n的大小，因为它最坏是0(n)的复杂度，那我们考虑优化就要从这个角度入手，看是否能够减少循环判断的次数。</p>\n<p> 然后我们就会发现，其实根本不需要遍历到n-1。我们都知道X &#x3D; sqrt(X)^2 , 那么很明显，当其中一个因数缩小，另外一个因数必然增大。由于我们考虑的是正整数范围，所以不存在因数是分数的情况，也就是说因数不能无限制缩小，最小应该是1。</p>\n<p> 那么我们就只用关注1~sqrt(X) 这个范围，因为另外一半里必然跟前一半一一对应。</p>\n<p> 所以这个算法就优化成了这样</p>\n<pre><code class=\"c++\">bool is_prime(int n )&#123;\nif(n&lt;2) return false;\nfor(int i=2;i&lt; = n/i;i++)&#123;\n    if(n%i==0)\n        return false;\n&#125;\nreturn true;\n&#125;\n</code></pre>\n<p>其实，大家可能已经发现了，其实这个循环的上限不是关键，关键是循环内的判断，因为一旦被整除，其实这个函数就已经返回false了。循环从2开始走，如果有约数，必然在2~sqrt(X)中有约数</p>\n</li>\n</ol>\n<h2 id=\"分解质因数\"><a href=\"#分解质因数\" class=\"headerlink\" title=\"分解质因数\"></a>分解质因数</h2><p>试除法    O(logn) ~ O(sqrt(n))</p>\n<p><strong>算法思想</strong></p>\n<p>使用试除法，当遍历到可以整除的i时，让i循环除n并记录次数，然后输出质因子i和其次数ai</p>\n<p>最后如果n有剩余且大于1，就直接输出n和其次数1</p>\n<p><strong>代码如下:</strong></p>\n<pre><code class=\"c++\">   //从小到大枚举所有数 n中最多只包含一个大于sqrt(n)的质因子\n\n   void divide(int n)&#123;\n    for(int i = 2;i &lt;= n/i;i++)&#123;\n        if(n%i==0)&#123;\n            int s = 0;\n            while(n%i==0)&#123;\n                n/=i;\n                s++;\n            &#125;\n\n            printf(&quot;%d %d\\n&quot;,i,s);\n        &#125;     \n    &#125;\n    if( n &gt; 1) printf(&quot;%d %d\\n&quot;,n,1);\n    puts(&quot;&quot;);\n   &#125;\n</code></pre>\n<p><strong>为什么是这样的？</strong></p>\n<p><code> 首先，我们要知道n中最多只包含一个大于sqrt(n)的质因子，这个可以用反证法来证明，假如说存在两个大于sqrt(n)的质因子，那么两个质因子的一次方乘积就已经大于n了，故至多存在1个大于sqrt(n)的质因子。</code></p>\n<p>我们举一个例子，<code>n=33  </code></p>\n<p><code>33 = 3^1 * 11^1</code> ,也就是33的质因子是3和11，11是大于根号33的</p>\n<p>好，明白了这一点，我们就能明白为什么循环条件是到sqrt(n)，为什么最后还要再判断n&gt;1。我们在不断除质数的过程中其实n已经越来越小了，如果n是1说明已经恰好除尽。否则，就说明n还剩了一个大于根号n的质因子，那么我们直接输出就可以了。</p>\n<hr>\n<p><em>截止现在，我们学习了如何判断一个数是否是质数以及如何将一个数分解成为若干质因子的积</em></p>\n<p><em>那么，假设我现在需要知道1~n中质数的个数，怎么办呢？当然，你可以双层for循环解决，但如果n比较大呢？将近n^2的复杂度是不是有点儿高呢，那怎么办呢？</em></p>\n<p><strong>下面我们就要来说这个问题</strong></p>\n<h2 id=\"筛质数\"><a href=\"#筛质数\" class=\"headerlink\" title=\"筛质数\"></a>筛质数</h2><p><em>筛质数要解决的问题就是快速求出n以内质数的个数</em></p>\n<ol>\n<li><p>朴素筛</p>\n<p><strong>算法思想</strong></p>\n<p>既然用除法作试除法一个一个判断太耗时了，那我们可以反其道而行之，我们不用除法，改用乘法去把每个数的倍数筛掉，因为如果n是x的倍数，那么n必然就不是质数，因为它至少有x这个约数</p>\n<p>我们用这个思想就可以从2开始遍历，把每个数的倍数筛掉。</p>\n<p><strong>具体实现</strong></p>\n<p>在具体的实现中，我们是这么来做的。定义primes[N]存放质数，cnt累加质数的个数，st[N]用来标记一个数是否被筛掉，筛掉为true</p>\n<p>我们开始遍历，首先如果当前这个数没有被筛掉，那么它就是一个质数，我们把它放到primes中，然后累加。</p>\n<p>然后我们将n以内i的所有倍数筛掉</p>\n<p>这样这个算法就完成了</p>\n<pre><code class=\"c++\">//朴素筛 O(nlogn)\nconst int N = 1000010 ;\nint primes[N] , cnt;\nbool st[N] ;\n\nvoid get_primes(int n)&#123;\n for(int i = 2;i&lt;=n;i++)&#123;\n     if(!st[i])&#123;\n         primes[cnt++]=i;\n     &#125;\n     for(int j = i+i;j&lt;=n;j+=i) st[j] = true ;\n &#125;\n&#125;\n</code></pre>\n<p>或许大家已经发现了，是否有一些数被多个i重复筛掉了，这里我们举一个简单的例子：8 &#x3D; 2^3,很显然8会被2、4重复筛。</p>\n<p>接下来我们再来考虑一下如何去进一步的优化</p>\n</li>\n<li><p>埃氏筛法</p>\n<p><strong>优化策略</strong></p>\n<p>其实只需要让n的质因子把n筛掉即可，如果i不是质数就不需要再筛i的倍数，大家可以思考一下。比如8&#x3D;2^3,i&#x3D;2就可以筛掉8，当i&#x3D;4时，i其实是一个合数，就不用筛了，因为4的倍数一定也是2的倍数。</p>\n<pre><code class=\"c++\">//质数定理 ： 1~n 中有 n/lnN 个质数 \n//优化--&gt; O(nloglogn)  \nconst int N = 1000010 ;\nint primes[N] , cnt;\nbool st[N] ;\n\nvoid get_primes(int n)&#123;\n for(int i = 2;i&lt;=n;i++)&#123;\n     if(!st[i])&#123;\n         primes[cnt++]=i;\n         for(int j = i+i;j&lt;=n;j+=i) st[j] = true ;\n     &#125;\n &#125;\n&#125;\n</code></pre>\n<p>那么可能大家又会想到，n会不会被多个质因子重复筛掉呢，想到这里，那博主真的要羡慕的哭出来了，毕竟当时想到这些的都是计算机界的dalao</p>\n<p><strong>线性筛法</strong>就是为了解决这个问题！</p>\n</li>\n<li><p>线性筛法</p>\n<p> <strong>优化策略</strong></p>\n<p> 让每一个合数都只被自己的最小质因子筛掉</p>\n<pre><code class=\"c++\">//线性筛法  10^7\n//n 只会被其最小质因子筛掉\nconst int N = 1000010 ;\nint primes[N] , cnt;\nbool st[N] ;\n\nvoid get_primes(int n)&#123;\n    for(int i = 2;i&lt;=n;i++)&#123;\n        if(!st[i]) primes[cnt++]=i;\n        for(int j = 0;primes[j] &lt;=n / i; j++ )&#123;\n            st[primes[j]*i] = true ;\n            if(i%primes[j] == 0) break; //primes[j]一定是i的最小质因子，\n        &#125;\n    &#125;\n&#125;\n\n分析循环体\n1. i%pj == 0\n    pj一定是i的最小质因子，pj一定是i * pj 的最小质因子\n2. i%pj!=0\n    pj一定小于i的所有质因子，pj也一定是i * pj的最小质因子\n\n所以说一个合数只会被自己的最小质因子筛掉\n</code></pre>\n</li>\n</ol>\n",
            "tags": [
                "算法",
                "数论",
                "质数"
            ]
        }
    ]
}